{"ast":null,"code":"/*\n* React Tooltip\n* {@link https://github.com/ReactTooltip/react-tooltip}\n* @copyright ReactTooltip Team\n* @license MIT\n*/\nimport e, { useLayoutEffect as t, useEffect as o, createContext as r, useState as l, useCallback as n, useMemo as c, useContext as i, useRef as s, useImperativeHandle as a } from \"react\";\nimport { arrow as u, computePosition as d, offset as p, flip as v, shift as m, autoUpdate as f } from \"@floating-ui/dom\";\nimport y from \"classnames\";\nconst h = \"react-tooltip-core-styles\",\n  w = \"react-tooltip-base-styles\",\n  b = {\n    core: !1,\n    base: !1\n  };\nfunction S({\n  css: e,\n  id: t = w,\n  type: o = \"base\",\n  ref: r\n}) {\n  var l, n;\n  if (!e || \"undefined\" == typeof document || b[o]) return;\n  if (\"core\" === o && \"undefined\" != typeof process && (null === (l = null === process || void 0 === process ? void 0 : process.env) || void 0 === l ? void 0 : l.REACT_TOOLTIP_DISABLE_CORE_STYLES)) return;\n  if (\"base\" !== o && \"undefined\" != typeof process && (null === (n = null === process || void 0 === process ? void 0 : process.env) || void 0 === n ? void 0 : n.REACT_TOOLTIP_DISABLE_BASE_STYLES)) return;\n  \"core\" === o && (t = h), r || (r = {});\n  const {\n    insertAt: c\n  } = r;\n  if (document.getElementById(t)) return void console.warn(`[react-tooltip] Element with id '${t}' already exists. Call \\`removeStyle()\\` first`);\n  const i = document.head || document.getElementsByTagName(\"head\")[0],\n    s = document.createElement(\"style\");\n  s.id = t, s.type = \"text/css\", \"top\" === c && i.firstChild ? i.insertBefore(s, i.firstChild) : i.appendChild(s), s.styleSheet ? s.styleSheet.cssText = e : s.appendChild(document.createTextNode(e)), b[o] = !0;\n}\nfunction g({\n  type: e = \"base\",\n  id: t = w\n} = {}) {\n  if (!b[e]) return;\n  \"core\" === e && (t = h);\n  const o = document.getElementById(t);\n  \"style\" === (null == o ? void 0 : o.tagName) ? null == o || o.remove() : console.warn(`[react-tooltip] Failed to remove 'style' element with id '${t}'. Call \\`injectStyle()\\` first`), b[e] = !1;\n}\nconst E = async ({\n    elementReference: e = null,\n    tooltipReference: t = null,\n    tooltipArrowReference: o = null,\n    place: r = \"top\",\n    offset: l = 10,\n    strategy: n = \"absolute\",\n    middlewares: c = [p(Number(l)), v({\n      fallbackAxisSideDirection: \"start\"\n    }), m({\n      padding: 5\n    })],\n    border: i\n  }) => {\n    if (!e) return {\n      tooltipStyles: {},\n      tooltipArrowStyles: {},\n      place: r\n    };\n    if (null === t) return {\n      tooltipStyles: {},\n      tooltipArrowStyles: {},\n      place: r\n    };\n    const s = c;\n    return o ? (s.push(u({\n      element: o,\n      padding: 5\n    })), d(e, t, {\n      placement: r,\n      strategy: n,\n      middleware: s\n    }).then(({\n      x: e,\n      y: t,\n      placement: o,\n      middlewareData: r\n    }) => {\n      var l, n;\n      const c = {\n          left: `${e}px`,\n          top: `${t}px`,\n          border: i\n        },\n        {\n          x: s,\n          y: a\n        } = null !== (l = r.arrow) && void 0 !== l ? l : {\n          x: 0,\n          y: 0\n        },\n        u = null !== (n = {\n          top: \"bottom\",\n          right: \"left\",\n          bottom: \"top\",\n          left: \"right\"\n        }[o.split(\"-\")[0]]) && void 0 !== n ? n : \"bottom\",\n        d = i && {\n          borderBottom: i,\n          borderRight: i\n        };\n      let p = 0;\n      if (i) {\n        const e = `${i}`.match(/(\\d+)px/);\n        p = (null == e ? void 0 : e[1]) ? Number(e[1]) : 1;\n      }\n      return {\n        tooltipStyles: c,\n        tooltipArrowStyles: {\n          left: null != s ? `${s}px` : \"\",\n          top: null != a ? `${a}px` : \"\",\n          right: \"\",\n          bottom: \"\",\n          ...d,\n          [u]: `-${4 + p}px`\n        },\n        place: o\n      };\n    })) : d(e, t, {\n      placement: \"bottom\",\n      strategy: n,\n      middleware: s\n    }).then(({\n      x: e,\n      y: t,\n      placement: o\n    }) => ({\n      tooltipStyles: {\n        left: `${e}px`,\n        top: `${t}px`\n      },\n      tooltipArrowStyles: {},\n      place: o\n    }));\n  },\n  A = (e, t) => !(\"CSS\" in window && \"supports\" in window.CSS) || window.CSS.supports(e, t),\n  _ = (e, t, o) => {\n    let r = null;\n    const l = function (...l) {\n      const n = () => {\n        r = null, o || e.apply(this, l);\n      };\n      o && !r && (e.apply(this, l), r = setTimeout(n, t)), o || (r && clearTimeout(r), r = setTimeout(n, t));\n    };\n    return l.cancel = () => {\n      r && (clearTimeout(r), r = null);\n    }, l;\n  },\n  O = e => null !== e && !Array.isArray(e) && \"object\" == typeof e,\n  T = (e, t) => {\n    if (e === t) return !0;\n    if (Array.isArray(e) && Array.isArray(t)) return e.length === t.length && e.every((e, o) => T(e, t[o]));\n    if (Array.isArray(e) !== Array.isArray(t)) return !1;\n    if (!O(e) || !O(t)) return e === t;\n    const o = Object.keys(e),\n      r = Object.keys(t);\n    return o.length === r.length && o.every(o => T(e[o], t[o]));\n  },\n  k = e => {\n    if (!(e instanceof HTMLElement || e instanceof SVGElement)) return !1;\n    const t = getComputedStyle(e);\n    return [\"overflow\", \"overflow-x\", \"overflow-y\"].some(e => {\n      const o = t.getPropertyValue(e);\n      return \"auto\" === o || \"scroll\" === o;\n    });\n  },\n  C = e => {\n    if (!e) return null;\n    let t = e.parentElement;\n    for (; t;) {\n      if (k(t)) return t;\n      t = t.parentElement;\n    }\n    return document.scrollingElement || document.documentElement;\n  },\n  L = \"undefined\" != typeof window ? t : o,\n  R = \"DEFAULT_TOOLTIP_ID\",\n  x = {\n    anchorRefs: new Set(),\n    activeAnchor: {\n      current: null\n    },\n    attach: () => {},\n    detach: () => {},\n    setActiveAnchor: () => {}\n  },\n  N = r({\n    getTooltipData: () => x\n  }),\n  $ = ({\n    children: t\n  }) => {\n    const [o, r] = l({\n        [R]: new Set()\n      }),\n      [i, s] = l({\n        [R]: {\n          current: null\n        }\n      }),\n      a = (e, ...t) => {\n        r(o => {\n          var r;\n          const l = null !== (r = o[e]) && void 0 !== r ? r : new Set();\n          return t.forEach(e => l.add(e)), {\n            ...o,\n            [e]: new Set(l)\n          };\n        });\n      },\n      u = (e, ...t) => {\n        r(o => {\n          const r = o[e];\n          return r ? (t.forEach(e => r.delete(e)), {\n            ...o\n          }) : o;\n        });\n      },\n      d = n((e = R) => {\n        var t, r;\n        return {\n          anchorRefs: null !== (t = o[e]) && void 0 !== t ? t : new Set(),\n          activeAnchor: null !== (r = i[e]) && void 0 !== r ? r : {\n            current: null\n          },\n          attach: (...t) => a(e, ...t),\n          detach: (...t) => u(e, ...t),\n          setActiveAnchor: t => ((e, t) => {\n            s(o => {\n              var r;\n              return (null === (r = o[e]) || void 0 === r ? void 0 : r.current) === t.current ? o : {\n                ...o,\n                [e]: t\n              };\n            });\n          })(e, t)\n        };\n      }, [o, i, a, u]),\n      p = c(() => ({\n        getTooltipData: d\n      }), [d]);\n    return e.createElement(N.Provider, {\n      value: p\n    }, t);\n  };\nfunction I(e = R) {\n  return i(N).getTooltipData(e);\n}\nconst j = ({\n  tooltipId: t,\n  children: r,\n  className: l,\n  place: n,\n  content: c,\n  html: i,\n  variant: a,\n  offset: u,\n  wrapper: d,\n  events: p,\n  positionStrategy: v,\n  delayShow: m,\n  delayHide: f\n}) => {\n  const {\n      attach: h,\n      detach: w\n    } = I(t),\n    b = s(null);\n  return o(() => (h(b), () => {\n    w(b);\n  }), []), e.createElement(\"span\", {\n    ref: b,\n    className: y(\"react-tooltip-wrapper\", l),\n    \"data-tooltip-place\": n,\n    \"data-tooltip-content\": c,\n    \"data-tooltip-html\": i,\n    \"data-tooltip-variant\": a,\n    \"data-tooltip-offset\": u,\n    \"data-tooltip-wrapper\": d,\n    \"data-tooltip-events\": p,\n    \"data-tooltip-position-strategy\": v,\n    \"data-tooltip-delay-show\": m,\n    \"data-tooltip-delay-hide\": f\n  }, r);\n};\nvar B = {\n    tooltip: \"core-styles-module_tooltip__3vRRp\",\n    fixed: \"core-styles-module_fixed__pcSol\",\n    arrow: \"core-styles-module_arrow__cvMwQ\",\n    noArrow: \"core-styles-module_noArrow__xock6\",\n    clickable: \"core-styles-module_clickable__ZuTTB\",\n    show: \"core-styles-module_show__Nt9eE\",\n    closing: \"core-styles-module_closing__sGnxF\"\n  },\n  z = {\n    tooltip: \"styles-module_tooltip__mnnfp\",\n    arrow: \"styles-module_arrow__K0L3T\",\n    dark: \"styles-module_dark__xNqje\",\n    light: \"styles-module_light__Z6W-X\",\n    success: \"styles-module_success__A2AKt\",\n    warning: \"styles-module_warning__SCK0X\",\n    error: \"styles-module_error__JvumD\",\n    info: \"styles-module_info__BWdHW\"\n  };\nconst D = ({\n    forwardRef: t,\n    id: r,\n    className: c,\n    classNameArrow: i,\n    variant: u = \"dark\",\n    anchorId: d,\n    anchorSelect: p,\n    place: v = \"top\",\n    offset: m = 10,\n    events: h = [\"hover\"],\n    openOnClick: w = !1,\n    positionStrategy: b = \"absolute\",\n    middlewares: S,\n    wrapper: g,\n    delayShow: A = 0,\n    delayHide: O = 0,\n    float: k = !1,\n    hidden: R = !1,\n    noArrow: x = !1,\n    clickable: N = !1,\n    closeOnEsc: $ = !1,\n    closeOnScroll: j = !1,\n    closeOnResize: D = !1,\n    openEvents: q,\n    closeEvents: H,\n    globalCloseEvents: M,\n    imperativeModeOnly: W,\n    style: P,\n    position: V,\n    afterShow: F,\n    afterHide: K,\n    content: U,\n    contentWrapperRef: X,\n    isOpen: Y,\n    defaultIsOpen: G = !1,\n    setIsOpen: Z,\n    activeAnchor: J,\n    setActiveAnchor: Q,\n    border: ee,\n    opacity: te,\n    arrowColor: oe,\n    role: re = \"tooltip\"\n  }) => {\n    var le;\n    const ne = s(null),\n      ce = s(null),\n      ie = s(null),\n      se = s(null),\n      ae = s(null),\n      [ue, de] = l({\n        tooltipStyles: {},\n        tooltipArrowStyles: {},\n        place: v\n      }),\n      [pe, ve] = l(!1),\n      [me, fe] = l(!1),\n      [ye, he] = l(null),\n      we = s(!1),\n      be = s(null),\n      {\n        anchorRefs: Se,\n        setActiveAnchor: ge\n      } = I(r),\n      Ee = s(!1),\n      [Ae, _e] = l([]),\n      Oe = s(!1),\n      Te = w || h.includes(\"click\"),\n      ke = Te || (null == q ? void 0 : q.click) || (null == q ? void 0 : q.dblclick) || (null == q ? void 0 : q.mousedown),\n      Ce = q ? {\n        ...q\n      } : {\n        mouseover: !0,\n        focus: !0,\n        mouseenter: !1,\n        click: !1,\n        dblclick: !1,\n        mousedown: !1\n      };\n    !q && Te && Object.assign(Ce, {\n      mouseenter: !1,\n      focus: !1,\n      mouseover: !1,\n      click: !0\n    });\n    const Le = H ? {\n      ...H\n    } : {\n      mouseout: !0,\n      blur: !0,\n      mouseleave: !1,\n      click: !1,\n      dblclick: !1,\n      mouseup: !1\n    };\n    !H && Te && Object.assign(Le, {\n      mouseleave: !1,\n      blur: !1,\n      mouseout: !1\n    });\n    const Re = M ? {\n      ...M\n    } : {\n      escape: $ || !1,\n      scroll: j || !1,\n      resize: D || !1,\n      clickOutsideAnchor: ke || !1\n    };\n    W && (Object.assign(Ce, {\n      mouseenter: !1,\n      focus: !1,\n      click: !1,\n      dblclick: !1,\n      mousedown: !1\n    }), Object.assign(Le, {\n      mouseleave: !1,\n      blur: !1,\n      click: !1,\n      dblclick: !1,\n      mouseup: !1\n    }), Object.assign(Re, {\n      escape: !1,\n      scroll: !1,\n      resize: !1,\n      clickOutsideAnchor: !1\n    })), L(() => (Oe.current = !0, () => {\n      Oe.current = !1;\n    }), []);\n    const xe = e => {\n      Oe.current && (e && fe(!0), setTimeout(() => {\n        Oe.current && (null == Z || Z(e), void 0 === Y && ve(e));\n      }, 10));\n    };\n    o(() => {\n      if (void 0 === Y) return () => null;\n      Y && fe(!0);\n      const e = setTimeout(() => {\n        ve(Y);\n      }, 10);\n      return () => {\n        clearTimeout(e);\n      };\n    }, [Y]), o(() => {\n      if (pe !== we.current) if (ae.current && clearTimeout(ae.current), we.current = pe, pe) null == F || F();else {\n        const e = (e => {\n          const t = e.match(/^([\\d.]+)(ms|s)$/);\n          if (!t) return 0;\n          const [, o, r] = t;\n          return Number(o) * (\"ms\" === r ? 1 : 1e3);\n        })(getComputedStyle(document.body).getPropertyValue(\"--rt-transition-show-delay\"));\n        ae.current = setTimeout(() => {\n          fe(!1), he(null), null == K || K();\n        }, e + 25);\n      }\n    }, [pe]);\n    const Ne = e => {\n        de(t => T(t, e) ? t : e);\n      },\n      $e = (e = A) => {\n        ie.current && clearTimeout(ie.current), me ? xe(!0) : ie.current = setTimeout(() => {\n          xe(!0);\n        }, e);\n      },\n      Ie = (e = O) => {\n        se.current && clearTimeout(se.current), se.current = setTimeout(() => {\n          Ee.current || xe(!1);\n        }, e);\n      },\n      je = e => {\n        var t;\n        if (!e) return;\n        const o = null !== (t = e.currentTarget) && void 0 !== t ? t : e.target;\n        if (!(null == o ? void 0 : o.isConnected)) return Q(null), void ge({\n          current: null\n        });\n        A ? $e() : xe(!0), Q(o), ge({\n          current: o\n        }), se.current && clearTimeout(se.current);\n      },\n      Be = () => {\n        N ? Ie(O || 100) : O ? Ie() : xe(!1), ie.current && clearTimeout(ie.current);\n      },\n      ze = ({\n        x: e,\n        y: t\n      }) => {\n        var o;\n        const r = {\n          getBoundingClientRect: () => ({\n            x: e,\n            y: t,\n            width: 0,\n            height: 0,\n            top: t,\n            left: e,\n            right: e,\n            bottom: t\n          })\n        };\n        E({\n          place: null !== (o = null == ye ? void 0 : ye.place) && void 0 !== o ? o : v,\n          offset: m,\n          elementReference: r,\n          tooltipReference: ne.current,\n          tooltipArrowReference: ce.current,\n          strategy: b,\n          middlewares: S,\n          border: ee\n        }).then(e => {\n          Ne(e);\n        });\n      },\n      De = e => {\n        if (!e) return;\n        const t = e,\n          o = {\n            x: t.clientX,\n            y: t.clientY\n          };\n        ze(o), be.current = o;\n      },\n      qe = e => {\n        var t;\n        if (!pe) return;\n        const o = e.target;\n        if (!o.isConnected) return;\n        if (null === (t = ne.current) || void 0 === t ? void 0 : t.contains(o)) return;\n        [document.querySelector(`[id='${d}']`), ...Ae].some(e => null == e ? void 0 : e.contains(o)) || (xe(!1), ie.current && clearTimeout(ie.current));\n      },\n      He = _(je, 50, !0),\n      Me = _(Be, 50, !0),\n      We = e => {\n        Me.cancel(), He(e);\n      },\n      Pe = () => {\n        He.cancel(), Me();\n      },\n      Ve = n(() => {\n        var e, t;\n        const o = null !== (e = null == ye ? void 0 : ye.position) && void 0 !== e ? e : V;\n        o ? ze(o) : k ? be.current && ze(be.current) : (null == J ? void 0 : J.isConnected) && E({\n          place: null !== (t = null == ye ? void 0 : ye.place) && void 0 !== t ? t : v,\n          offset: m,\n          elementReference: J,\n          tooltipReference: ne.current,\n          tooltipArrowReference: ce.current,\n          strategy: b,\n          middlewares: S,\n          border: ee\n        }).then(e => {\n          Oe.current && Ne(e);\n        });\n      }, [pe, J, U, P, v, null == ye ? void 0 : ye.place, m, b, V, null == ye ? void 0 : ye.position, k]);\n    o(() => {\n      var e, t;\n      const o = new Set(Se);\n      Ae.forEach(e => {\n        o.add({\n          current: e\n        });\n      });\n      const r = document.querySelector(`[id='${d}']`);\n      r && o.add({\n        current: r\n      });\n      const l = () => {\n          xe(!1);\n        },\n        n = C(J),\n        c = C(ne.current);\n      Re.scroll && (window.addEventListener(\"scroll\", l), null == n || n.addEventListener(\"scroll\", l), null == c || c.addEventListener(\"scroll\", l));\n      let i = null;\n      Re.resize ? window.addEventListener(\"resize\", l) : J && ne.current && (i = f(J, ne.current, Ve, {\n        ancestorResize: !0,\n        elementResize: !0,\n        layoutShift: !0\n      }));\n      const s = e => {\n        \"Escape\" === e.key && xe(!1);\n      };\n      Re.escape && window.addEventListener(\"keydown\", s), Re.clickOutsideAnchor && window.addEventListener(\"click\", qe);\n      const a = [],\n        u = e => {\n          pe && (null == e ? void 0 : e.target) === J || je(e);\n        },\n        p = e => {\n          pe && (null == e ? void 0 : e.target) === J && Be();\n        },\n        v = [\"mouseover\", \"mouseout\", \"mouseenter\", \"mouseleave\", \"focus\", \"blur\"],\n        m = [\"click\", \"dblclick\", \"mousedown\", \"mouseup\"];\n      Object.entries(Ce).forEach(([e, t]) => {\n        t && (v.includes(e) ? a.push({\n          event: e,\n          listener: We\n        }) : m.includes(e) && a.push({\n          event: e,\n          listener: u\n        }));\n      }), Object.entries(Le).forEach(([e, t]) => {\n        t && (v.includes(e) ? a.push({\n          event: e,\n          listener: Pe\n        }) : m.includes(e) && a.push({\n          event: e,\n          listener: p\n        }));\n      }), k && a.push({\n        event: \"pointermove\",\n        listener: De\n      });\n      const y = () => {\n          Ee.current = !0;\n        },\n        h = () => {\n          Ee.current = !1, Be();\n        };\n      return N && !ke && (null === (e = ne.current) || void 0 === e || e.addEventListener(\"mouseenter\", y), null === (t = ne.current) || void 0 === t || t.addEventListener(\"mouseleave\", h)), a.forEach(({\n        event: e,\n        listener: t\n      }) => {\n        o.forEach(o => {\n          var r;\n          null === (r = o.current) || void 0 === r || r.addEventListener(e, t);\n        });\n      }), () => {\n        var e, t;\n        Re.scroll && (window.removeEventListener(\"scroll\", l), null == n || n.removeEventListener(\"scroll\", l), null == c || c.removeEventListener(\"scroll\", l)), Re.resize ? window.removeEventListener(\"resize\", l) : null == i || i(), Re.clickOutsideAnchor && window.removeEventListener(\"click\", qe), Re.escape && window.removeEventListener(\"keydown\", s), N && !ke && (null === (e = ne.current) || void 0 === e || e.removeEventListener(\"mouseenter\", y), null === (t = ne.current) || void 0 === t || t.removeEventListener(\"mouseleave\", h)), a.forEach(({\n          event: e,\n          listener: t\n        }) => {\n          o.forEach(o => {\n            var r;\n            null === (r = o.current) || void 0 === r || r.removeEventListener(e, t);\n          });\n        });\n      };\n    }, [J, Ve, me, Se, Ae, q, H, M, Te, A, O]), o(() => {\n      var e, t;\n      let o = null !== (t = null !== (e = null == ye ? void 0 : ye.anchorSelect) && void 0 !== e ? e : p) && void 0 !== t ? t : \"\";\n      !o && r && (o = `[data-tooltip-id='${r.replace(/'/g, \"\\\\'\")}']`);\n      const l = new MutationObserver(e => {\n        const t = [],\n          l = [];\n        e.forEach(e => {\n          if (\"attributes\" === e.type && \"data-tooltip-id\" === e.attributeName) {\n            e.target.getAttribute(\"data-tooltip-id\") === r ? t.push(e.target) : e.oldValue === r && l.push(e.target);\n          }\n          if (\"childList\" === e.type) {\n            if (J) {\n              const t = [...e.removedNodes].filter(e => 1 === e.nodeType);\n              if (o) try {\n                l.push(...t.filter(e => e.matches(o))), l.push(...t.flatMap(e => [...e.querySelectorAll(o)]));\n              } catch (e) {}\n              t.some(e => {\n                var t;\n                return !!(null === (t = null == e ? void 0 : e.contains) || void 0 === t ? void 0 : t.call(e, J)) && (fe(!1), xe(!1), Q(null), ie.current && clearTimeout(ie.current), se.current && clearTimeout(se.current), !0);\n              });\n            }\n            if (o) try {\n              const r = [...e.addedNodes].filter(e => 1 === e.nodeType);\n              t.push(...r.filter(e => e.matches(o))), t.push(...r.flatMap(e => [...e.querySelectorAll(o)]));\n            } catch (e) {}\n          }\n        }), (t.length || l.length) && _e(e => [...e.filter(e => !l.includes(e)), ...t]);\n      });\n      return l.observe(document.body, {\n        childList: !0,\n        subtree: !0,\n        attributes: !0,\n        attributeFilter: [\"data-tooltip-id\"],\n        attributeOldValue: !0\n      }), () => {\n        l.disconnect();\n      };\n    }, [r, p, null == ye ? void 0 : ye.anchorSelect, J]), o(() => {\n      Ve();\n    }, [Ve]), o(() => {\n      if (!(null == X ? void 0 : X.current)) return () => null;\n      const e = new ResizeObserver(() => {\n        setTimeout(() => Ve());\n      });\n      return e.observe(X.current), () => {\n        e.disconnect();\n      };\n    }, [U, null == X ? void 0 : X.current]), o(() => {\n      var e;\n      const t = document.querySelector(`[id='${d}']`),\n        o = [...Ae, t];\n      J && o.includes(J) || Q(null !== (e = Ae[0]) && void 0 !== e ? e : t);\n    }, [d, Ae, J]), o(() => (G && xe(!0), () => {\n      ie.current && clearTimeout(ie.current), se.current && clearTimeout(se.current);\n    }), []), o(() => {\n      var e;\n      let t = null !== (e = null == ye ? void 0 : ye.anchorSelect) && void 0 !== e ? e : p;\n      if (!t && r && (t = `[data-tooltip-id='${r.replace(/'/g, \"\\\\'\")}']`), t) try {\n        const e = Array.from(document.querySelectorAll(t));\n        _e(e);\n      } catch (e) {\n        _e([]);\n      }\n    }, [r, p, null == ye ? void 0 : ye.anchorSelect]), o(() => {\n      ie.current && (clearTimeout(ie.current), $e(A));\n    }, [A]);\n    const Fe = null !== (le = null == ye ? void 0 : ye.content) && void 0 !== le ? le : U,\n      Ke = pe && Object.keys(ue.tooltipStyles).length > 0;\n    return a(t, () => ({\n      open: e => {\n        if (null == e ? void 0 : e.anchorSelect) try {\n          document.querySelector(e.anchorSelect);\n        } catch (t) {\n          return void console.warn(`[react-tooltip] \"${e.anchorSelect}\" is not a valid CSS selector`);\n        }\n        he(null != e ? e : null), (null == e ? void 0 : e.delay) ? $e(e.delay) : xe(!0);\n      },\n      close: e => {\n        (null == e ? void 0 : e.delay) ? Ie(e.delay) : xe(!1);\n      },\n      activeAnchor: J,\n      place: ue.place,\n      isOpen: Boolean(me && !R && Fe && Ke)\n    })), me && !R && Fe ? e.createElement(g, {\n      id: r,\n      role: re,\n      className: y(\"react-tooltip\", B.tooltip, z.tooltip, z[u], c, `react-tooltip__place-${ue.place}`, B[Ke ? \"show\" : \"closing\"], Ke ? \"react-tooltip__show\" : \"react-tooltip__closing\", \"fixed\" === b && B.fixed, N && B.clickable),\n      onTransitionEnd: e => {\n        ae.current && clearTimeout(ae.current), pe || \"opacity\" !== e.propertyName || (fe(!1), he(null), null == K || K());\n      },\n      style: {\n        ...P,\n        ...ue.tooltipStyles,\n        opacity: void 0 !== te && Ke ? te : void 0\n      },\n      ref: ne\n    }, Fe, e.createElement(g, {\n      className: y(\"react-tooltip-arrow\", B.arrow, z.arrow, i, x && B.noArrow),\n      style: {\n        ...ue.tooltipArrowStyles,\n        background: oe ? `linear-gradient(to right bottom, transparent 50%, ${oe} 50%)` : void 0\n      },\n      ref: ce\n    })) : null;\n  },\n  q = ({\n    content: t\n  }) => e.createElement(\"span\", {\n    dangerouslySetInnerHTML: {\n      __html: t\n    }\n  }),\n  H = e.forwardRef(({\n    id: t,\n    anchorId: r,\n    anchorSelect: n,\n    content: c,\n    html: i,\n    render: a,\n    className: u,\n    classNameArrow: d,\n    variant: p = \"dark\",\n    place: v = \"top\",\n    offset: m = 10,\n    wrapper: f = \"div\",\n    children: h = null,\n    events: w = [\"hover\"],\n    openOnClick: b = !1,\n    positionStrategy: S = \"absolute\",\n    middlewares: g,\n    delayShow: E = 0,\n    delayHide: _ = 0,\n    float: O = !1,\n    hidden: T = !1,\n    noArrow: k = !1,\n    clickable: C = !1,\n    closeOnEsc: L = !1,\n    closeOnScroll: R = !1,\n    closeOnResize: x = !1,\n    openEvents: N,\n    closeEvents: $,\n    globalCloseEvents: j,\n    imperativeModeOnly: B = !1,\n    style: z,\n    position: H,\n    isOpen: M,\n    defaultIsOpen: W = !1,\n    disableStyleInjection: P = !1,\n    border: V,\n    opacity: F,\n    arrowColor: K,\n    setIsOpen: U,\n    afterShow: X,\n    afterHide: Y,\n    role: G = \"tooltip\"\n  }, Z) => {\n    const [J, Q] = l(c),\n      [ee, te] = l(i),\n      [oe, re] = l(v),\n      [le, ne] = l(p),\n      [ce, ie] = l(m),\n      [se, ae] = l(E),\n      [ue, de] = l(_),\n      [pe, ve] = l(O),\n      [me, fe] = l(T),\n      [ye, he] = l(f),\n      [we, be] = l(w),\n      [Se, ge] = l(S),\n      [Ee, Ae] = l(null),\n      [_e, Oe] = l(null),\n      Te = s(P),\n      {\n        anchorRefs: ke,\n        activeAnchor: Ce\n      } = I(t),\n      Le = e => null == e ? void 0 : e.getAttributeNames().reduce((t, o) => {\n        var r;\n        if (o.startsWith(\"data-tooltip-\")) {\n          t[o.replace(/^data-tooltip-/, \"\")] = null !== (r = null == e ? void 0 : e.getAttribute(o)) && void 0 !== r ? r : null;\n        }\n        return t;\n      }, {}),\n      Re = e => {\n        const t = {\n          place: e => {\n            var t;\n            re(null !== (t = e) && void 0 !== t ? t : v);\n          },\n          content: e => {\n            Q(null != e ? e : c);\n          },\n          html: e => {\n            te(null != e ? e : i);\n          },\n          variant: e => {\n            var t;\n            ne(null !== (t = e) && void 0 !== t ? t : p);\n          },\n          offset: e => {\n            ie(null === e ? m : Number(e));\n          },\n          wrapper: e => {\n            var t;\n            he(null !== (t = e) && void 0 !== t ? t : f);\n          },\n          events: e => {\n            const t = null == e ? void 0 : e.split(\" \");\n            be(null != t ? t : w);\n          },\n          \"position-strategy\": e => {\n            var t;\n            ge(null !== (t = e) && void 0 !== t ? t : S);\n          },\n          \"delay-show\": e => {\n            ae(null === e ? E : Number(e));\n          },\n          \"delay-hide\": e => {\n            de(null === e ? _ : Number(e));\n          },\n          float: e => {\n            ve(null === e ? O : \"true\" === e);\n          },\n          hidden: e => {\n            fe(null === e ? T : \"true\" === e);\n          },\n          \"class-name\": e => {\n            Ae(e);\n          }\n        };\n        Object.values(t).forEach(e => e(null)), Object.entries(e).forEach(([e, o]) => {\n          var r;\n          null === (r = t[e]) || void 0 === r || r.call(t, o);\n        });\n      };\n    o(() => {\n      Q(c);\n    }, [c]), o(() => {\n      te(i);\n    }, [i]), o(() => {\n      re(v);\n    }, [v]), o(() => {\n      ne(p);\n    }, [p]), o(() => {\n      ie(m);\n    }, [m]), o(() => {\n      ae(E);\n    }, [E]), o(() => {\n      de(_);\n    }, [_]), o(() => {\n      ve(O);\n    }, [O]), o(() => {\n      fe(T);\n    }, [T]), o(() => {\n      ge(S);\n    }, [S]), o(() => {\n      Te.current !== P && console.warn(\"[react-tooltip] Do not change `disableStyleInjection` dynamically.\");\n    }, [P]), o(() => {\n      \"undefined\" != typeof window && window.dispatchEvent(new CustomEvent(\"react-tooltip-inject-styles\", {\n        detail: {\n          disableCore: \"core\" === P,\n          disableBase: P\n        }\n      }));\n    }, []), o(() => {\n      var e;\n      const o = new Set(ke);\n      let l = n;\n      if (!l && t && (l = `[data-tooltip-id='${t.replace(/'/g, \"\\\\'\")}']`), l) try {\n        document.querySelectorAll(l).forEach(e => {\n          o.add({\n            current: e\n          });\n        });\n      } catch (e) {\n        console.warn(`[react-tooltip] \"${l}\" is not a valid CSS selector`);\n      }\n      const c = document.querySelector(`[id='${r}']`);\n      if (c && o.add({\n        current: c\n      }), !o.size) return () => null;\n      const i = null !== (e = null != _e ? _e : c) && void 0 !== e ? e : Ce.current,\n        s = new MutationObserver(e => {\n          e.forEach(e => {\n            var t;\n            if (!i || \"attributes\" !== e.type || !(null === (t = e.attributeName) || void 0 === t ? void 0 : t.startsWith(\"data-tooltip-\"))) return;\n            const o = Le(i);\n            Re(o);\n          });\n        }),\n        a = {\n          attributes: !0,\n          childList: !1,\n          subtree: !1\n        };\n      if (i) {\n        const e = Le(i);\n        Re(e), s.observe(i, a);\n      }\n      return () => {\n        s.disconnect();\n      };\n    }, [ke, Ce, _e, r, n]), o(() => {\n      (null == z ? void 0 : z.border) && console.warn(\"[react-tooltip] Do not set `style.border`. Use `border` prop instead.\"), V && !A(\"border\", `${V}`) && console.warn(`[react-tooltip] \"${V}\" is not a valid \\`border\\`.`), (null == z ? void 0 : z.opacity) && console.warn(\"[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead.\"), F && !A(\"opacity\", `${F}`) && console.warn(`[react-tooltip] \"${F}\" is not a valid \\`opacity\\`.`);\n    }, []);\n    let xe = h;\n    const Ne = s(null);\n    if (a) {\n      const t = a({\n        content: (null == _e ? void 0 : _e.getAttribute(\"data-tooltip-content\")) || J || null,\n        activeAnchor: _e\n      });\n      xe = t ? e.createElement(\"div\", {\n        ref: Ne,\n        className: \"react-tooltip-content-wrapper\"\n      }, t) : null;\n    } else J && (xe = J);\n    ee && (xe = e.createElement(q, {\n      content: ee\n    }));\n    const $e = {\n      forwardRef: Z,\n      id: t,\n      anchorId: r,\n      anchorSelect: n,\n      className: y(u, Ee),\n      classNameArrow: d,\n      content: xe,\n      contentWrapperRef: Ne,\n      place: oe,\n      variant: le,\n      offset: ce,\n      wrapper: ye,\n      events: we,\n      openOnClick: b,\n      positionStrategy: Se,\n      middlewares: g,\n      delayShow: se,\n      delayHide: ue,\n      float: pe,\n      hidden: me,\n      noArrow: k,\n      clickable: C,\n      closeOnEsc: L,\n      closeOnScroll: R,\n      closeOnResize: x,\n      openEvents: N,\n      closeEvents: $,\n      globalCloseEvents: j,\n      imperativeModeOnly: B,\n      style: z,\n      position: H,\n      isOpen: M,\n      defaultIsOpen: W,\n      border: V,\n      opacity: F,\n      arrowColor: K,\n      setIsOpen: U,\n      afterShow: X,\n      afterHide: Y,\n      activeAnchor: _e,\n      setActiveAnchor: e => Oe(e),\n      role: G\n    };\n    return e.createElement(D, {\n      ...$e\n    });\n  });\n\"undefined\" != typeof window && window.addEventListener(\"react-tooltip-inject-styles\", e => {\n  e.detail.disableCore || S({\n    css: `:root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}`,\n    type: \"core\"\n  }), e.detail.disableBase || S({\n    css: `\n.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`,\n    type: \"base\"\n  });\n});\nexport { H as Tooltip, $ as TooltipProvider, j as TooltipWrapper, g as removeStyle };","map":null,"metadata":{},"sourceType":"module"}